class MinPQ:

    def __init__(self):
        self._pq = [None] * 8
        self._size = 0

        self._iter_object = None

    def enqueue(self, item):
        self._size += 1

        self._pq[self._size] = item

        self.__swim()

        if self._size >= int(len(self._pq) / 2):
            self.__resize(len(self._pq) * 2)

    def popMin(self):
        self.__swap(1, self._size)

        item = self._pq[self._size]

        self._pq[self._size] = None
        self._size -= 1

        self.__sink()

        if self._size <= int(len(self._pq) / 4):
            self.__resize(int(len(self._pq) / 2))

        return item

    def isEmpty(self):
        return self._size == 0

    def getSize(self):
        return self._size

    def __swim(self):
        if self._size == 0:
            return

        index = self._size
        compare_index = int(index / 2)

        while index > 1:
            if self._pq[index] < self._pq[compare_index]:
                self.__swap(index, compare_index)

                index = compare_index
                compare_index = int(index / 2)
            else:
                return

    def __sink(self):
        index = 1
        compare_index = 2

        while compare_index <= self._size:
            if compare_index + 1 <= self._size:
                if self._pq[compare_index] > self._pq[compare_index + 1]:
                    compare_index += 1

            if self._pq[index] > self._pq[compare_index]:
                self.__swap(index, compare_index)

                index = compare_index
                compare_index = index * 2
            else:
                return

    def __swap(self, first_index, second_index):
        temp = self._pq[first_index]
        self._pq[first_index] = self._pq[second_index]
        self._pq[second_index] = temp

    def __resize(self, size):
        temp = self._pq
        self._pq = [None] * size

        for i in range(1, self._size + 1):
            self._pq[i] = temp[i]

    def __iter__(self):
        self._iter_object = MinPQ()

        for i in range(1, self._size + 1):
            self._iter_object.enqueue(self._pq[i])

        return self

    def __next__(self):
        if not self._iter_object.isEmpty():
            return self._iter_object.popMin()
        else:
            raise StopIteration
